load("D:/360安全浏览器下载/Recipe.csv")
LS
ls
setwd("C:/Users/YifeiWang/Desktop/INFS7205")
dataset = read.csv("7205dataset.csv",sep = " ",header = FALSE)
#why there is 100001 obs?
head(dataset)
#remove the first value "100000"
dataset = data.frame(key = dataset$V1[2:100001],x1 = dataset$V2[2:100001],x2 = dataset$V3[2:100001])
#generally look into dataset
summary(dataset)
length(which(dataset$x1 == dataset$x2))
length(which(dataset$x1 > dataset$x2))
length(which(dataset$x1 < dataset$x2))
#looks most likely that x1,x2 are random number between 0-100000
# hypothesis 1: use mean of x1,x2 to order dataset is the most effecient R-tree:
for (i in 1:nrow(dataset)) {
dataset$mean[i] = (dataset$x1[i]+dataset$x2[i])/2
}
dataset_mean = dataset[order(dataset$mean), ]
# if there is m branches in parent nodes
#  we put b_max data points in each child node
# for simplity, only consider no underflow case
generate_r_tree = function(m,dataset_table) {
b_min = integer(0.4*m)
b_max = m
dataset_mean_tree = dataset_table
data_layer = 1
while(b_max^data_layer < nrow(dataset_mean_tree)){
col_num  = ncol(dataset_mean_tree) + data_layer
dataset_mean_tree = data.frame(dataset_mean_tree, parent_layer = NA)
for(i in c(seq(1,nrow(dataset_mean_tree),b_max^(data_layer)),nrow(dataset_mean_tree))){
if(i+b_max^data_layer-1<= nrow(dataset_mean_tree)){
child_nodes_min = dataset_mean_tree$mean[i]
child_nodes_max = dataset_mean_tree$mean[i+b_max^data_layer-1]
for(n in seq(i,i+b_max^data_layer-1,1)){
dataset_mean_tree[n,col_num] = paste(child_nodes_min,child_nodes_max)
}
}else{
child_nodes_min = dataset_mean_tree$mean[i]
child_nodes_max = dataset_mean_tree$mean[nrow(dataset_mean_tree)]
for(n in seq(i,nrow(dataset_mean_tree),1)){
dataset_mean_tree[n,col_num] = paste(child_nodes_min,child_nodes_max)
}
}
}
data_layer = data_layer + 1
}
col_num  = ncol(dataset_mean_tree) + 1
dataset_mean_tree = data.frame(dataset_mean_tree, parent_layer1 = NA)
child_nodes_min = dataset_mean_tree$mean[1]
child_nodes_max = dataset_mean_tree$mean[nrow(dataset_mean_tree)]
for(n in seq(1,nrow(dataset_mean_tree),1)){
dataset_mean_tree[n,col_num] = paste(child_nodes_min,child_nodes_max)
}
return(dataset_mean_tree)
}
# list of m values that will not cause underflow
m_list = NULL
for(m_val in 1:nrow(dataset)){
b_min_val = as.integer(0.4*m_val)
b_max_val = m_val
if ((nrow(dataset) - as.integer(nrow(dataset)/b_max_val)*b_max_val) >= b_min_val) {
m_list = c(m_list,m_val)
}
}
#choose random five m value from v_list
m_list_s = sample(m_list,5)
rtree_1 = generate_r_tree(m_list_s[1],dataset_mean)
View(rtree_1)
